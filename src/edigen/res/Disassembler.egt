%auto_gen_warning
%package_spec

import static %decoder_full_class.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * The disassembler.
 */
class %disasm_class extends SimpleDisassembler {

    /**
     * An instruction mnemonic format string with associated values.
     */
    private static class Format {
        private String format;
        private int[] values;

        public Format(String format, int[] values) {
            this.format = format;
            this.values = values;
        }

        public String getFormat() {
            return format;
        }

        public int[] getValues() {
            return values;
        }
    }

    private static final Map<Set<Integer>, Format> formatMap;

    private IMemoryContext memory;
    private IDecoder decoder;

    static {
        String[] formats = {
          %disasm_formats
        };
        
        int[][] values = {
            %disasm_values
        };
        
        formatMap = new HashMap<Set<Integer>, Format>();
        
        for (int i = 0; i < formats.length; i++) {
            Set<Integer> formatValues = new HashSet<Integer>();
            
            for (int value : values[i]) {
                formatValues.add(value);
            }
            
            formatMap.put(formatValues, new Format(formats[i], values[i]));
        }
    }

    /**
     * The constructor.
     * @param memory the memory context which will be used to read instructions
     * @param decoder the decoder to use to decode instructions
     */
    public %disasm_class(IMemoryContext memory, IDecoder decoder) {
        this.memory = memory;
        this.decoder = decoder;
    }
    
    /**
     * Disassembles an instruction.
     * @param memoryLocation the starting address of the instruction
     * @return the disassembled instruction
     */
    @Override
    public CPUInstruction disassemble(int memoryLocation) {
        String mnemonic;
        String code;
        
        try {
            Instruction instruction = decoder.decode(memoryLocation);
            Format format = formatMap.get(instruction.getRuleSet());
            mnemonic = createMnemonic(format.getFormat(), format.getValues());
            
            StringBuilder codeBuilder = new StringBuilder();
            
            for (byte number : instruction.getContent()) {
                codeBuilder.append(String.format("%02X ", number));
            }
            
            code = codeBuilder.toString();
        } catch (InvalidInstructionException ex) {
            mnemonic = "unknown";
            code = String.format("%02X", (Byte) memory.read(memoryLocation));
        }
        
        return new CPUInstruction(memoryLocation, mnemonic, code);
    }
    
    /**
     * Returns an address of the instruction located right after the current
     * instruction.
     * @param memoryLocation the starting address of the current instruction
     * @return the starting address of the next instruction
     */
    @Override
    public int getNextInstructionLocation(int memoryLocation) {
        try {
            return decoder.decode(memoryLocation).getEndLocation() + 1;
        } catch (InvalidInstructionException ex) {
            return memoryLocation + 1;
        }
    }

    /**
     * Returns the instruction mnemonic.
     * @param format the format string
     * @param values the array of values (used to derermine the order of rules)
     * @return the instruction mnenomic
     */
    private String createMnemonic(String format, int[] values) {
        return "";
    }
}